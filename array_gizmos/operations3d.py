
"""
3D array operations.
"""

import numpy as np
import math

def positive_slicing(M):
    """
    for 3d matrix M determine I,J,K (start, end) slicing of minimal volume containing all positive M[i,j,k]
    """
    def minmax(nz):
        m = max(nz.min()-1, 0)
        M = nz.max() + 1
        return (m, M)
    slices = np.zeros((3, 2), dtype=np.int)
    Itest = M.max(axis=2).max(axis=1)
    (inz,) = np.nonzero(Itest > 0)
    slices[0] = minmax(inz) # (inz.min(), inz.max()+1)
    Jtest = M.max(axis=2).max(axis=0)
    (jnz,) = np.nonzero(Jtest > 0)
    slices[1] = minmax(jnz) # (jnz.min(), jnz.max()+1)
    Ktest = M.max(axis=1).max(axis=0)
    (knz,) = np.nonzero(Ktest > 0)
    slices[2] = minmax(knz) # (knz.min(), knz.max()+1)
    return slices

def unify_slicing(s1, s2):
    "combine slicings s1 and s2 into smallest slicing containing both s1 and s2."
    slices = np.zeros((3, 2), dtype=np.int)
    slices[:, 0] = np.minimum(s1[:, 0], s2[:, 0])
    slices[:, 1] = np.maximum(s1[:, 1], s2[:, 1])
    return slices

def slice3(M, s):
    "Slice M by array generated by positive_slicing."
    # xxx not neeeded?  For completeness
    im, iM = s[0]
    jm, jM = s[1]
    km, kM = s[2]
    return M[im:iM, jm:jM, km:kM]

def reduced_shape(array):
    "Make dimensions closer to equal by striding over larger dimensions."
    shape = array.shape
    m = min(*shape)
    #[sI, sJ, sK] = np.array(shape, dtype=np.int) // m
    #return array[::sI, ::sJ, ::sK]
    return resample(array, [m, m, m])

def expanded_shape(array):
    "Make dimensions closer to equal by expanding smaller dimensions."
    # xxx not really finished: too slow.
    shape = array.shape
    M = max(*shape)
    (I, J, K) = shape
    Is = M / I
    if Is > 1:
        expanded = np.zeros([M, J, K], dtype=array.dtype)
        for i_m in range(M):
            expanded[i_m] = array[int(i_m / Is)]
    return expanded

def specific_shape(array, size):
    "Force all dimensions of a 3d array to equal size by repeating or subsampling values."
    return resample(array, [size, size, size])

def resample(array, sizes):
    (I, J, K) = array.shape
    size = sizes[0]
    r = size / I
    adjusted = np.zeros((size, J, K), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[i] = array[i_r]
    size = sizes[1]
    array = adjusted
    adjusted = np.zeros((sizes[0], size, K), dtype=array.dtype)
    r = size / J
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, i] = array[:, i_r]
    size = sizes[2]
    array = adjusted
    r = size / K
    adjusted = np.zeros((sizes[0], sizes[1], size), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, :, i] = array[:, :, i_r]
    return adjusted

def rectify_scaling(I, dI, dside):
    return int(I * dI / dside)

def rectify(array, dI, dJ, dK, dside):
    """
    resample array with voxel dimensions dI x dJ x dK
    producing resampled array with voxel dimensions dside x dside x dside.
    """
    (I, J, K) = array.shape
    new_shape = (
        rectify_scaling(I, dI, dside),
        rectify_scaling(J, dJ, dside),
        rectify_scaling(K, dK, dside))
    return resample(array, new_shape)


def speckle(array, speckle_ratio=0.03):
    """
    Randomly select speckled subset of array nonzero elements.
    """
    if speckle_ratio == 1:
        return array.copy()
    assert speckle_ratio > 0 and speckle_ratio < 1, \
        "bad speckle ratio: " + repr(speckle_ratio)
    r = np.random.random(array.shape)
    filter = (r < speckle_ratio)
    return np.where(filter, array, 0)

def expand_broadcastable(a1, a2):
    "make a1 and a2 into bigger broadcastable arrays (hacky expedient, for now)"
    bigger = tuple(np.maximum(a1.shape, a2.shape))
    def force(a):
        (I, J, K) = a.shape
        result = np.zeros(bigger, dtype=a.dtype)
        result[:I, :J, :K] = a
        return result
    return (force(a1), force(a2))

def shearKJ(array, radians):
    "Shear the 3d array at the middle by radians in the JK dimensions."
    # xxx might be generalizable to 2d etc if reworked for IJ
    # Used primarily to implement rotation.
    (I, J, K) = array.shape[:3]
    result = array.copy()
    result[:] = 0
    Jmid = J / 2
    shifter = np.tan(radians)
    for j in range(J):
        shift = int((j - Jmid) * shifter)
        dst_mn = max(0, - shift)
        dst_mx = min(K, K - shift)
        src_mn = max(0, shift)
        src_mx = min(K, K + shift)
        try:
            result[:, j, dst_mn:dst_mx] = array[:, j, src_mn:src_mx]
        except Exception as e:
            print("shearKJ exception dst", dst_mn, dst_mx, "src", src_mn, src_mx)
            raise
    return result

def swapABC(array, A=0, B=1, C=2):
    "Swap all 3 axes to specified order. This creates an array view very quickly."
    result = array
    order = [A, B, C]
    assert set(order) == set([0,1,2]), "Bad indices: " + repr(order)
    for (p0,p1) in [(0,1), (1,2), (0,1)]:
        order0 = order[p0]
        order1 = order[p1]
        if order0 > order1:
            result = np.swapaxes(result, p0, p1)
            order[p0] = order1
            order[p1] = order0
    assert order[0] < order[1] < order[2], repr(order)
    return result

def invertABC(A=0, B=1, C=2):
    "Inverse swap order."
    map = {A:0, B:1, C:2}
    return [map[i] for i in range(3)]

def shearABC(array, radians, A=0, B=1, C=2):
    "Apply KJ shear to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    shear = shearKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(shear, iA, iB, iC)
    return back


def rot90JK(array):
    "Rotate in J and K dimensions 90 degrees."
    T = np.swapaxes(array, 1, 2)
    return T[:, ::-1, :]

def rot90ABC(array, A=0, B=1, C=2):
    "Apply KJ rotate 90 degrees to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    rot = rot90JK(array)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rot, iA, iB, iC)
    return back

# based on https://www.ocf.berkeley.edu/~fricke/projects/israel/paeth/rotation_by_shearing.html

pi4 = np.pi / 4.0
pi2 = np.pi / 2.0
pi34 = np.pi * 3.0 / 4.0
epsilon = 0.01

def is_tiny(number):
    return abs(number) < epsilon

def rotateKJ45(array, theta):
    "Rotate array in JK dimensions by theta in range -45..45 degrees."
    #global sA, sB, sC  # DEBUG ONLY
    if is_tiny(theta):
        return array # micro optimization
    assert theta >= -pi4 and theta <= pi4, "theta not in [-pi/4..pi/4]" + repr([pi4, theta])
    alpha = - np.tan(0.5 * theta)
    beta = np.sin(theta)
    sA = shearKJ(array, alpha)
    sB = shearABC(sA, beta, 0, 2, 1)
    sC = shearKJ(sB, alpha)
    return sC

def rotateKJ(array, theta):
    "Rotate array in JK dimensions by theta in range -180..180 degrees."
    # xxx could remove range restriction.
    if is_tiny(theta):
        return array # micro optimization
    assert -np.pi - 1 <= theta <= np.pi + 1, "theta not in range -pi..pi." + repr(theta)
    # note: rotations are fast because they only make views of the array (?)
    buffer = array
    theta0 = theta
    if theta > pi4:
        if theta < pi34:
            # 90 degree rotation
            buffer = rot90JK(array)
            theta0 = theta - pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = theta - np.pi
    elif theta < -pi4:
        if theta > -pi34:
            # 270 degrees
            buffer = rot90JK(rot90JK(rot90JK(array)))
            theta0 = theta + pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = np.pi + theta
    return rotateKJ45(buffer, theta0)

def rotateABC(array, radians, A=0, B=1, C=2):
    "Apply KJ rotate to swapped dimensions, and swap back after."
    if is_tiny(radians):
        return array # micro optimization
    swap = swapABC(array, A, B, C)
    rotate = rotateKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rotate, iA, iB, iC)
    return back

def extrude0(labels_array):
    "extrude values along axis 0"
    extruded = labels_array[0].copy()
    for labelsi in labels_array:
        nz = (labelsi > 0)
        extruded = np.choose(nz, [extruded, labelsi])
        #volume[i] = extruded
    return extruded

def rotate3d(array, theta, phi, gamma=0):
    "Generalized rotation: rotate by theta in KJ and phi in IK."
    R1 = rotateKJ(array, theta) # KJ rotation
    R2 = rotateABC(R1, phi, 2, 0, 1)  # IJ rotation
    R3 = rotateABC(R2, gamma, 1, 2, 0)  # IK rotation
    return R3

def rotation_buffer(arr3d):
    "Embed array in another array large enough to support rotations."
    (I, J, K) = arr3d.shape[:3]
    N = math.ceil(np.sqrt(I*I + J*J + K*K))
    new_shape = (N, N, N) + arr3d.shape[3:]
    buffer = np.zeros(new_shape, dtype=arr3d.dtype)
    Istart = round(0.5 * (N-I))
    Jstart = round(0.5 * (N-J))
    Kstart = round(0.5 * (N-K))
    buffer[Istart:Istart+I, Jstart:Jstart+J, Kstart:Kstart+K] = arr3d
    return buffer


def shade(array, shadow_index_map, shadow_mask):
    all_shaded = shadow_index_map[array]
    shadowed = np.where(shadow_mask, all_shaded, array)
    return shadowed

def shadow3d0(array3d, shadow_index_map):
    "shadow using the planes from index 0."
    shadow_mask = (array3d[0] * 0).astype(bool)
    result = array3d.copy()
    for (i, plane) in enumerate(array3d):
        result[i] = shade(plane, shadow_index_map, shadow_mask)
        shadow_mask = np.logical_or(shadow_mask, (plane != 0))
    return result

def shadow3d(array3d, shadow_index_map, axis=0):
    (A, B, C) = (0, 1, 2)
    assert axis in (0,1,2), "bad axis for shadowing " + repr(axis)
    if axis == 1:
        (A, B, C) = (1, 0, 2)
    if axis == 2:
        (A, B, C) = (2, 1, 0)
    [iA, iB, iC] = invertABC(A, B, C)
    swapped = swapABC(array3d, A, B, C)
    shaded0 = shadow3d0(swapped, shadow_index_map)
    shaded = swapABC(shaded0, iA, iB, iC)
    return shaded
