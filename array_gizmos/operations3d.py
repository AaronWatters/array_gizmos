
"""
3D array operations.
"""

import numpy as np
import math

def positive_slicing(M):
    """
    for 3d matrix M determine I,J,K (start, end) slicing of minimal volume containing all positive M[i,j,k]
    """
    def minmax(nz):
        m = max(nz.min()-1, 0)
        M = nz.max() + 1
        return (m, M)
    slices = np.zeros((3, 2), dtype=np.int)
    Itest = M.max(axis=2).max(axis=1)
    (inz,) = np.nonzero(Itest > 0)
    slices[0] = minmax(inz) # (inz.min(), inz.max()+1)
    Jtest = M.max(axis=2).max(axis=0)
    (jnz,) = np.nonzero(Jtest > 0)
    slices[1] = minmax(jnz) # (jnz.min(), jnz.max()+1)
    Ktest = M.max(axis=1).max(axis=0)
    (knz,) = np.nonzero(Ktest > 0)
    slices[2] = minmax(knz) # (knz.min(), knz.max()+1)
    return slices

def unify_slicing(s1, s2):
    "combine slicings s1 and s2 into smallest slicing containing both s1 and s2."
    slices = np.zeros((3, 2), dtype=np.int)
    slices[:, 0] = np.minimum(s1[:, 0], s2[:, 0])
    slices[:, 1] = np.maximum(s1[:, 1], s2[:, 1])
    return slices

def slice3(M, s):
    "Slice M by array generated by positive_slicing."
    # xxx not neeeded?  For completeness
    im, iM = s[0]
    jm, jM = s[1]
    km, kM = s[2]
    return M[im:iM, jm:jM, km:kM]

def reduced_shape(array):
    "Make dimensions closer to equal by striding over larger dimensions."
    shape = array.shape
    m = min(*shape)
    [sI, sJ, sK] = np.array(shape, dtype=np.int) // m
    return array[::sI, ::sJ, ::sK]

def expanded_shape(array):
    "Make dimensions closer to equal by expanding smaller dimensions."
    # xxx not really finished: too slow.
    shape = array.shape
    M = max(*shape)
    (I, J, K) = shape
    Is = M / I
    if Is > 1:
        expanded = np.zeros([M, J, K], dtype=array.dtype)
        for i_m in range(M):
            expanded[i_m] = array[int(i_m / Is)]
    return expanded

def specific_shape(array, size):
    "Force all dimensions to equal size by repeating or subsampling values."
    (I, J, K) = array.shape
    r = size / I
    adjusted = np.zeros((size, J, K), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[i] = array[i_r]
    array = adjusted
    adjusted = np.zeros((size, size, K), dtype=array.dtype)
    r = size / J
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, i] = array[:, i_r]
    array = adjusted
    r = size / K
    adjusted = np.zeros((size, size, size), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, :, i] = array[:, :, i_r]
    return adjusted

def shearKJ(array, radians):
    "Shear the 3d array at the middle by radians in the JK dimensions."
    # xxx might be generalizable to 2d etc if reworked for IJ
    # Used primarily to implement rotation.
    (I, J, K) = array.shape
    result = array.copy()
    result[:] = 0
    Jmid = J / 2
    shifter = np.tan(radians)
    for j in range(J):
        shift = int((j - Jmid) * shifter)
        dst_mn = max(0, - shift)
        dst_mx = min(K, K - shift)
        src_mn = max(0, shift)
        src_mx = min(K, K + shift)
        try:
            result[:, j, dst_mn:dst_mx] = array[:, j, src_mn:src_mx]
        except Exception as e:
            print("shearKJ exception dst", dst_mn, dst_mx, "src", src_mn, src_mx)
            raise
    return result

def swapABC(array, A=0, B=1, C=2):
    "Swap all 3 axes to specified order. This creates an array view very quickly."
    result = array
    order = [A, B, C]
    assert set(order) == set([0,1,2]), "Bad indices: " + repr(order)
    for (p0,p1) in [(0,1), (1,2), (0,1)]:
        order0 = order[p0]
        order1 = order[p1]
        if order0 > order1:
            result = np.swapaxes(result, p0, p1)
            order[p0] = order1
            order[p1] = order0
    assert order[0] < order[1] < order[2], repr(order)
    return result

def invertABC(A=0, B=1, C=2):
    "Inverse swap order."
    map = {A:0, B:1, C:2}
    return [map[i] for i in range(3)]

def shearABC(array, radians, A=0, B=1, C=2):
    "Apply KJ shear to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    shear = shearKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(shear, iA, iB, iC)
    return back


def rot90JK(array):
    "Rotate in J and K dimensions 90 degrees."
    T = np.swapaxes(array, 1, 2)
    return T[:, ::-1, :]

def rot90ABC(array, A=0, B=1, C=2):
    "Apply KJ rotate 90 degrees to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    rot = rot90JK(array)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rot, iA, iB, iC)
    return back

# based on https://www.ocf.berkeley.edu/~fricke/projects/israel/paeth/rotation_by_shearing.html

pi4 = np.pi / 4.0
pi2 = np.pi / 2.0
pi34 = np.pi * 3.0 / 4.0

def rotateKJ45(array, theta):
    "Rotate array in JK dimensions by theta in range -45..45 degrees."
    #global sA, sB, sC  # DEBUG ONLY
    assert theta >= -pi4 and theta <= pi4, "theta not in [-pi/4..pi/4]" + repr([pi4, theta])
    alpha = - np.tan(0.5 * theta)
    beta = np.sin(theta)
    sA = shearKJ(array, alpha)
    sB = shearABC(sA, beta, 0, 2, 1)
    sC = shearKJ(sB, alpha)
    return sC

def rotateKJ(array, theta):
    "Rotate array in JK dimensions by theta in range -180..180 degrees."
    # xxx could remove range restriction.
    assert -np.pi - 1 <= theta <= np.pi + 1, "theta not in range -pi..pi." + repr(theta)
    # note: rotations are fast because they only make views of the array (?)
    buffer = array
    theta0 = theta
    if theta > pi4:
        if theta < pi34:
            # 90 degree rotation
            buffer = rot90JK(array)
            theta0 = theta - pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = theta - np.pi
    elif theta < -pi4:
        if theta > -pi34:
            # 270 degrees
            buffer = rot90JK(rot90JK(rot90JK(array)))
            theta0 = theta + pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = np.pi + theta
    return rotateKJ45(buffer, theta0)

def rotateABC(array, radians, A=0, B=1, C=2):
    "Apply KJ rotate to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    rotate = rotateKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rotate, iA, iB, iC)
    return back

def extrude0(labels_array):
    "extrude values along axis 0"
    extruded = labels_array[0].copy()
    for labelsi in labels_array:
        nz = (labelsi > 0)
        extruded = np.choose(nz, [extruded, labelsi])
        #volume[i] = extruded
    return extruded

def rotate3d(array, theta, phi):
    "Generalized rotation: rotate by theta in KJ and phi in IK."
    R1 = rotateKJ(array, theta)
    R2 = rotateABC(R1, phi, 2, 0, 1)
    return R2  

def rotation_buffer(arr3d):
    "Embed array in another array large enough to support rotations."
    (I, J, K) = arr3d.shape
    N = math.ceil(np.sqrt(I*I + J*J + K*K))
    buffer = np.zeros((N, N, N), dtype=arr3d.dtype)
    Istart = round(0.5 * (N-I))
    Jstart = round(0.5 * (N-J))
    Kstart = round(0.5 * (N-K))
    buffer[Istart:Istart+I, Jstart:Jstart+J, Kstart:Kstart+K] = arr3d
    return buffer
