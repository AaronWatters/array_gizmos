
"""
3D array operations.
"""

import numpy as np
import math
from . import transforms3d as t3d

def positive_slicing(M):
    """
    for 3d matrix M determine I,J,K (start, end) slicing of minimal volume containing all positive M[i,j,k]
    """
    def minmax(nz):
        m = max(nz.min()-1, 0)
        M = nz.max() + 1
        return (m, M)
    slices = np.zeros((3, 2), dtype=np.int)
    Itest = M.max(axis=2).max(axis=1)
    (inz,) = np.nonzero(Itest > 0)
    slices[0] = minmax(inz) # (inz.min(), inz.max()+1)
    Jtest = M.max(axis=2).max(axis=0)
    (jnz,) = np.nonzero(Jtest > 0)
    slices[1] = minmax(jnz) # (jnz.min(), jnz.max()+1)
    Ktest = M.max(axis=1).max(axis=0)
    (knz,) = np.nonzero(Ktest > 0)
    slices[2] = minmax(knz) # (knz.min(), knz.max()+1)
    return slices

def unify_slicing(s1, s2):
    "combine slicings s1 and s2 into smallest slicing containing both s1 and s2."
    slices = np.zeros((3, 2), dtype=np.int)
    slices[:, 0] = np.minimum(s1[:, 0], s2[:, 0])
    slices[:, 1] = np.maximum(s1[:, 1], s2[:, 1])
    return slices

def slice3(M, s):
    "Slice M by array generated by positive_slicing."
    # xxx not neeeded?  For completeness
    im, iM = s[0]
    jm, jM = s[1]
    km, kM = s[2]
    return M[im:iM, jm:jM, km:kM]

def reduced_shape(array):
    "Make dimensions closer to equal by striding over larger dimensions."
    shape = array.shape
    m = min(*shape)
    #[sI, sJ, sK] = np.array(shape, dtype=np.int) // m
    #return array[::sI, ::sJ, ::sK]
    return resample(array, [m, m, m])

def expanded_shape(array):
    "Make dimensions closer to equal by expanding smaller dimensions."
    # xxx not really finished: too slow.
    shape = array.shape
    M = max(*shape)
    (I, J, K) = shape
    Is = M / I
    if Is > 1:
        expanded = np.zeros([M, J, K], dtype=array.dtype)
        for i_m in range(M):
            expanded[i_m] = array[int(i_m / Is)]
    return expanded

def specific_shape(array, size):
    "Force all dimensions of a 3d array to equal size by repeating or subsampling values."
    return resample(array, [size, size, size])

def resample(array, sizes):
    (I, J, K) = array.shape
    size = sizes[0]
    r = size / I
    adjusted = np.zeros((size, J, K), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[i] = array[i_r]
    size = sizes[1]
    array = adjusted
    adjusted = np.zeros((sizes[0], size, K), dtype=array.dtype)
    r = size / J
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, i] = array[:, i_r]
    size = sizes[2]
    array = adjusted
    r = size / K
    adjusted = np.zeros((sizes[0], sizes[1], size), dtype=array.dtype)
    for i in range(size):
        i_r = int(i / r)
        adjusted[:, :, i] = array[:, :, i_r]
    return adjusted

def rectify_scaling(I, dI, dside):
    return int(I * dI / dside)

def rectify(array, dI, dJ, dK, dside):
    """
    resample array with voxel dimensions dI x dJ x dK
    producing resampled array with voxel dimensions dside x dside x dside.
    """
    (I, J, K) = array.shape
    new_shape = (
        rectify_scaling(I, dI, dside),
        rectify_scaling(J, dJ, dside),
        rectify_scaling(K, dK, dside))
    return resample(array, new_shape)


def speckle(array, speckle_ratio=0.03):
    """
    Randomly select speckled subset of array nonzero elements.
    """
    if speckle_ratio == 1:
        return array.copy()
    assert speckle_ratio > 0 and speckle_ratio < 1, \
        "bad speckle ratio: " + repr(speckle_ratio)
    r = np.random.random(array.shape)
    filter = (r < speckle_ratio)
    return np.where(filter, array, 0)

def expand_broadcastable(a1, a2):
    "make a1 and a2 into bigger broadcastable arrays (hacky expedient, for now)"
    bigger = tuple(np.maximum(a1.shape, a2.shape))
    def force(a):
        (I, J, K) = a.shape
        result = np.zeros(bigger, dtype=a.dtype)
        result[:I, :J, :K] = a
        return result
    return (force(a1), force(a2))

def shearKJ(array, radians):
    "Shear the 3d array at the middle by radians in the JK dimensions."
    # xxx might be generalizable to 2d etc if reworked for IJ
    # Used primarily to implement rotation.
    (I, J, K) = array.shape[:3]
    result = array.copy()
    result[:] = 0
    Jmid = J / 2
    shifter = np.tan(radians)
    for j in range(J):
        shift = int((j - Jmid) * shifter)
        dst_mn = max(0, - shift)
        dst_mx = min(K, K - shift)
        src_mn = max(0, shift)
        src_mx = min(K, K + shift)
        try:
            result[:, j, dst_mn:dst_mx] = array[:, j, src_mn:src_mx]
        except Exception as e:
            print("shearKJ exception dst", dst_mn, dst_mx, "src", src_mn, src_mx)
            raise
    return result

def swapABC(array, A=0, B=1, C=2):
    "Swap all 3 axes to specified order. This creates an array view very quickly."
    result = array
    order = [A, B, C]
    assert set(order) == set([0,1,2]), "Bad indices: " + repr(order)
    for (p0,p1) in [(0,1), (1,2), (0,1)]:
        order0 = order[p0]
        order1 = order[p1]
        if order0 > order1:
            result = np.swapaxes(result, p0, p1)
            order[p0] = order1
            order[p1] = order0
    assert order[0] < order[1] < order[2], repr(order)
    return result

def invertABC(A=0, B=1, C=2):
    "Inverse swap order."
    map = {A:0, B:1, C:2}
    return [map[i] for i in range(3)]

def shearABC(array, radians, A=0, B=1, C=2):
    "Apply KJ shear to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    shear = shearKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(shear, iA, iB, iC)
    return back


def rot90JK(array):
    "Rotate in J and K dimensions 90 degrees."
    T = np.swapaxes(array, 1, 2)
    return T[:, ::-1, :]

def rot90ABC(array, A=0, B=1, C=2):
    "Apply KJ rotate 90 degrees to swapped dimensions, and swap back after."
    swap = swapABC(array, A, B, C)
    rot = rot90JK(array)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rot, iA, iB, iC)
    return back

# based on https://www.ocf.berkeley.edu/~fricke/projects/israel/paeth/rotation_by_shearing.html

pi4 = np.pi / 4.0
pi2 = np.pi / 2.0
pi34 = np.pi * 3.0 / 4.0
epsilon = 0.01

def is_tiny(number):
    return abs(number) < epsilon

def rotateKJ45(array, theta):
    "Rotate array in JK dimensions by theta in range -45..45 degrees."
    #global sA, sB, sC  # DEBUG ONLY
    if is_tiny(theta):
        return array # micro optimization
    assert theta >= -pi4 and theta <= pi4, "theta not in [-pi/4..pi/4]" + repr([pi4, theta])
    alpha = - np.tan(0.5 * theta)
    beta = np.sin(theta)
    sA = shearKJ(array, alpha)
    sB = shearABC(sA, beta, 0, 2, 1)
    sC = shearKJ(sB, alpha)
    return sC

def rotateKJ(array, theta):
    "Rotate array in JK dimensions by theta in range -180..180 degrees."
    # xxx could remove range restriction.
    if is_tiny(theta):
        return array # micro optimization
    assert -np.pi - 1 <= theta <= np.pi + 1, "theta not in range -pi..pi." + repr(theta)
    # note: rotations are fast because they only make views of the array (?)
    buffer = array
    theta0 = theta
    if theta > pi4:
        if theta < pi34:
            # 90 degree rotation
            buffer = rot90JK(array)
            theta0 = theta - pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = theta - np.pi
    elif theta < -pi4:
        if theta > -pi34:
            # 270 degrees
            buffer = rot90JK(rot90JK(rot90JK(array)))
            theta0 = theta + pi2
        else:
            # 180 degrees
            buffer = rot90JK(rot90JK(array))
            theta0 = np.pi + theta
    return rotateKJ45(buffer, theta0)

def rotateABC(array, radians, A=0, B=1, C=2):
    "Apply KJ rotate to swapped dimensions, and swap back after."
    if is_tiny(radians):
        return array # micro optimization
    swap = swapABC(array, A, B, C)
    rotate = rotateKJ(swap, radians)
    [iA, iB, iC] = invertABC(A, B, C)
    back = swapABC(rotate, iA, iB, iC)
    return back

def extrude0(labels_array):
    "extrude values along axis 0"
    extruded = labels_array[0].copy()
    for labelsi in labels_array:
        nz = (labelsi > 0)
        extruded = np.choose(nz, [extruded, labelsi])
        #volume[i] = extruded
    return extruded

def rotate3d(array, theta, phi, gamma=0):
    "Generalized rotation: rotate by theta in KJ and phi in IK."
    R1 = rotateKJ(array, theta) # KJ rotation
    R2 = rotateABC(R1, phi, 2, 0, 1)  # IJ rotation
    R3 = rotateABC(R2, gamma, 1, 2, 0)  # IK rotation
    return R3

def rotation_buffer(arr3d):
    "Embed array in another array large enough to support rotations."
    (I, J, K) = arr3d.shape[:3]
    N = math.ceil(np.sqrt(I*I + J*J + K*K))
    new_shape = (N, N, N) + arr3d.shape[3:]
    buffer = np.zeros(new_shape, dtype=arr3d.dtype)
    Istart = round(0.5 * (N-I))
    Jstart = round(0.5 * (N-J))
    Kstart = round(0.5 * (N-K))
    buffer[Istart:Istart+I, Jstart:Jstart+J, Kstart:Kstart+K] = arr3d
    return buffer


def shade(array, shadow_index_map, shadow_mask):
    all_shaded = shadow_index_map[array]
    shadowed = np.where(shadow_mask, all_shaded, array)
    return shadowed

def shape_indices0(shape3d):
    """
    Generate array of indices (i,j,k,1) for each element in 3d array of given shape
    Simple implemantation for testing.
    """
    (I, J, K) = shape3d
    result = np.zeros((I, J, K, 4), dtype=np.int)
    for i in range(I):
        for j in range(J):
            for k in range(K):
                result[i, j, k] = (i, j, k, 1)
    return result

def shape_indices(shape3d):
    """
    Generate array of indices (i,j,k,1) for each element in 3d array of given shape
    Fast implementation using numpy broadcasting.
    """
    (I, J, K) = shape3d
    i_coords = np.arange(I).reshape((I, 1, 1))
    j_coords = np.arange(J).reshape((1, J, 1))
    k_coords = np.arange(K).reshape((1, 1, K))
    ones = np.ones((I, J, K), dtype=np.int)
    result = np.zeros((I, J, K, 4), dtype=np.int)
    result[:, :, :, 0] = i_coords
    result[:, :, :, 1] = j_coords
    result[:, :, :, 2] = k_coords
    result[:, :, :, 3] = ones
    return result

def transform_indices(indices, affine4x4):
    """
    Apply 4x4 affine transformation to array of indices.
    indices is array of shape (I,J,K,4) where last dimension is (i,j,k,1)
    affine4x4 is 4x4 numpy array.
    Returns transformed indices of same shape.
    """
    #print("transform_indices input:", indices)
    (I, J, K, _) = indices.shape
    flat_indices = indices.reshape((I*J*K, 4)).T  # shape (4, I*J*K)
    transformed_flat = affine4x4 @ flat_indices  # matrix multiplication
    transformed = transformed_flat.T.reshape((I, J, K, 4))
    #print("transform_indices output:", transformed)
    result = transformed.astype(np.int)
    #print ("transform_indices result:", result)
    return result

# This is an alternate rotation to rotate3d that
# seems to be slower but produces better results, maybe,

def airplane_rotate_array3d(array3d, yaw, pitch, roll):
    translate = (0, 0, 0)
    transform_matrix = t3d.airplane_matrix(translate, yaw, pitch, roll)
    rotated_array = rotate_array3d(array3d, transform_matrix)
    return rotated_array

def rotate_indices(shape, rotation3d_matrix):
    def transform(x, y, z):
        v = np.array([x, y, z, 1.0], dtype=float)
        t = rotation3d_matrix @ v
        return t[:3]
    (I, J, K) = shape
    origin = transform(0, 0, 0)
    dI = transform(1, 0, 0) - origin
    dJ = transform(0, 1, 0) - origin
    dK = transform(0, 0, 1) - origin
    root = origin.reshape([1, 1, 3])
    row = np.zeros([K, 3], dtype=float)
    acc = root.copy()
    inc = dK.reshape([1, 3])
    for k in range(K):
        row[k] = acc
        acc += inc
    lrow = row.reshape([1, K, 3])
    layer = np.zeros([J, K, 3], dtype=float)
    acc = lrow.copy()
    inc = dJ.reshape([1, 1, 3])
    for j in range(J):
        layer[j] = acc
        acc += inc
    vlayer = layer.reshape([1, J, K, 3])
    acc = vlayer.copy()
    inc = dI.reshape([1, 1, 1, 3])
    volume = np.zeros([I, J, K, 3], dtype=float)
    for i in range(I):
        volume[i] = acc
        acc += inc
    return volume.astype(int)

def rotate_array3d(array3d, rotation3d_matrix):
    """
    Rotate the 3d array using the 3d rotation matrix,
    choosing translation that keeps the array centered
    and choosing the shape of the output array to fit all rotated points.
    """
    # determine the extents of the rotated array using the corners
    (I, J, K) = array3d.shape[:3]
    #print ("rotate_array3d input shape:", array3d.shape)
    corners = np.array([
        [0, 0, 0, 1],
        [0, 0, K-1, 1],
        [0, J-1, 0, 1],
        [0, J-1, K-1, 1],
        [I-1, 0, 0, 1],
        [I-1, 0, K-1, 1],
        [I-1, J-1, 0, 1],
        [I-1, J-1, K-1, 1],
    ])
    #print ("rotate_array3d corners:", corners)
    rotated_corners = (rotation3d_matrix @ corners.T).T
    #print("rotate_array3d rotated corners:", rotated_corners)
    min_coords = rotated_corners[:, :3].min(axis=0)
    max_coords = rotated_corners[:, :3].max(axis=0)
    #print("rotated corners min:", min_coords, "max:", max_coords)
    #inverse_rotation = np.linalg.inv(rotation3d_matrix)
    #print("rotate_array3d inverse rotation matrix:", inverse_rotation)
    translation = -min_coords
    #translation = center_new - center_old
    #print("rotate_array3d translation:", translation)
    translation_matrix = t3d.translation_matrix(*translation)
    to_output_transform = translation_matrix @ rotation3d_matrix
    # for testing only
    #test_corners = (to_output_transform @ corners.T).T
    #print ("test: rotated and translated corners", test_corners)
    to_input_transform = np.linalg.inv(to_output_transform)
    output_shape = (max_coords - min_coords + 1).astype(np.int)
    rotated_array = np.zeros(output_shape, dtype=array3d.dtype)
    #output_indices = shape_indices(output_shape)
    #transformed_indices = transform_indices(output_indices, to_input_transform)
    transformed_indices = rotate_indices(output_shape, to_input_transform)
    i_indices = transformed_indices[:, :, :, 0].ravel()
    j_indices = transformed_indices[:, :, :, 1].ravel()
    k_indices = transformed_indices[:, :, :, 2].ravel()
    valid_mask = (
        (i_indices >= 0) & (i_indices < I) &
        (j_indices >= 0) & (j_indices < J) &
        (k_indices >= 0) & (k_indices < K)
    )
    #print("i_indices", i_indices)
    #print("j_indices", j_indices)
    #print("k_indices", k_indices)
    #print("valid_mask", valid_mask)
    i_valid = i_indices[valid_mask]
    j_valid = j_indices[valid_mask]
    k_valid = k_indices[valid_mask]
    values = array3d[i_valid, j_valid, k_valid]
    #print("values", values)
    flat = rotated_array.ravel()
    flat[valid_mask] = values.ravel()
    #print("flat", flat)
    return rotated_array

def shadow3d0(array3d, shadow_index_map):
    "shadow using the planes from index 0."
    shadow_mask = (array3d[0] * 0).astype(bool)
    result = array3d.copy()
    for (i, plane) in enumerate(array3d):
        result[i] = shade(plane, shadow_index_map, shadow_mask)
        shadow_mask = np.logical_or(shadow_mask, (plane != 0))
    return result

def shadow3d(array3d, shadow_index_map, axis=0):
    (A, B, C) = (0, 1, 2)
    assert axis in (0,1,2), "bad axis for shadowing " + repr(axis)
    if axis == 1:
        (A, B, C) = (1, 0, 2)
    if axis == 2:
        (A, B, C) = (2, 1, 0)
    [iA, iB, iC] = invertABC(A, B, C)
    swapped = swapABC(array3d, A, B, C)
    shaded0 = shadow3d0(swapped, shadow_index_map)
    shaded = swapABC(shaded0, iA, iB, iC)
    return shaded
